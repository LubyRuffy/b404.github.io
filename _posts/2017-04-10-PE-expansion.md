---
title: 'PE(二)'
layout: post
tags: 
  - reading-notes
  - sec
  - reverse
category: 
  - sec
  - reverse
comments: true
share: true
---
对PE的一些扩充

* TOC
{:toc}

<!--more-->

## 加载配置信息

加载配置信息最初只用在Windows NT操作系统，作为文件头部的延伸部分，后来被用作异常处理。加载配置信息表中存放了基于结构化异常处理(SEH)技术的各种异常句柄。当程序运行发生异常后，操作系统会根据异常类别对异常进行分发处理，并依据这些句柄实施程序流程的转向，保证系统能从异常中全身而退。

### 加载配置信息的概念

PE中的加载配置信息存储在加载配置结构(Load Configuration Structure)的数据结构中。加载配置结构是PE中定义的一种基本数据类型，最初仅用于WindowsNT，定义提供Windows NT操作系统加载PE时用到的一些附加信息。后该部分的含义发生变化，不再定义加载用的配置信息，而是被专门用于定义基于SEH技术相关数据。所以叫**异常处理表**更加合理。

若PE中该部分表中没有对应的异常类别处理函数句柄，OS将会调用其内核模式的异常分发函数终止应用程序的运行。这样可以阻止因异常句柄导致的溢出被利用。

通常，链接器会提供一个默认的加载配置结构，该结构包含了预留的SEH数据。若用户代码提供该结构，则必须由用户来完成设置新的预留SEH字段，否则链接器不会将SEH数据加入到加载配置信息中。

### 结构化异常

- 中断：常由外部条件引发
- 异常：常是代码或者数据中的条件导致处理器生成的，异常与正在执行的指令有关。异常是内部中断，发生异常，CPU中断当前进程转到异常处理程序，这些护理程序地址记录在中断描述符表(IDT)的数据结构中，对应的处理程序存储在ntoskrnl.exe文件中


### 异常分类

SEH使用了与硬件平台相关的数据指针，在不同的硬件平台，SEH的实现方法是不同的。在x86平台上的SEH处理框架中，把异常分为：

- 硬异常(系统异常)
 - 故障异常：指令执行失败引起。发生异常时，自动压栈的是失败指令的地址，而不是它的下一条指令的地址。(当从异常便利过程返回时，可以重新执行一遍这条指令)
 - 陷阱异常：执行自陷指令引起。异常的返回地址是自陷指令的下一条指令所在的地址。
 - 终止异常：无法恢复的严重出错，如硬件故障、系统表出现错误。
- 软异常（程序抛出异常）

### 异常处理

- 内核模式下的异常处理
- 用户模式下的异常处理

SEH机制：在执行某段代码过程中，发生了特定种类异常，就执行另一段指定代码。

Windows在系统空间和用户空间都有一个先进后出的异常处理队列ExceptionList。每当程序进入一个SEH框架时，就把一个带有长程跳转目标地址的数据结构挂入相应空间的异常处理队列，成为其一个节点。在内核控件将节点挂入系统空间的队列，在用户空间队列则挂入用户空间队列。

## 动态加载技术

动态加载技术是编写病毒程序、补丁程序必须的技术。该技术可以让程序设计者脱离复杂的导入表结构，在程序空间中构造类似导入表的调用引入函数机制。动态加载技术的核心是对调用函数的地址获取，调用函数位于动态链接库中。动态链接库在程序运行时会被加载到进程的虚拟地址空间。

与动态库有关的主要函数：
- LoadLibrary(或MFC的AfxLoadLibrary)，装载动态链接库
- GetProcAddress,获取要引入的函数的VA，将符号名或标记号转换为DLL内部地址。
- FreeLibrary(或MFC的AfxFreeLibrary)，释放动态链接库

DLL动态链接库能实现Windows应用程序共享资源、节省内存空间、提高效率。常见动态链接库包含导出函数和资源，也有一些只包含资源。通常Windows动态链接库后缀是`.dll`、`.drv`、`.fon`，静态链接库是`.lib`。


编程中使用动态加载技术：：

1. 获取kernel32.dll的基地址
2. 获取`GetProcAddress`函数的地址(进一步获取LoadLibrary函数的地址)
3. 在代码中使用获取的函数地址编程


## PE变形

变形是指通过改变链接器生成的PE文件内容，扩大或缩小文件尺寸。常见的四种静态PE文件的变形技术：

- 结构重叠技术:将数据结构进行重叠
- 空间调整技术：调整DOS头的`e_flanew`值
- 数据转移技术:变量存储、代码存储（连续空间长度无法容纳所有代码，则可以将代码分解）
- 数据压缩技术

变形技术可用的空间：

- 文件头部未用字段
- 大小不固定的数据块(DOS STUB、PE扩展头IMAGE_OPTIONAL_HEADER32、数据目录项、节表)
- 因对齐产生的补足空间

PE变形的原则：

- 数据目录表个数必须大于等于2
- PE文件头可以没有节，但必须将文件头的字段(NT文件头)的`NumberOfSection`设为1
- 导入表是PE的核心。要想在已有的PE中静态引入动态链接库的函数，必须通过变形技术构造一个合理的导入表(结构合理)或重构已有导入表
- 节的对齐尺寸必须大于或等于文件的对齐尺寸
- 数据可存储在内存中的任何位置(文件头或其他节中)，代码和数据一样，可以在内存的任何位置，但所在节的属性必须可读、可写、可执行。
- 部分字段需要注意修改





![PE变形需要关注的字段.png](/img/reversecore_assets/PE文件/PE变形需要关注的字段.png)

![变形时固定字段.png](/img/reversecore_assets/PE文件/变形时固定字段.png)



## PE补丁技术

PE补丁：

- - 动态补丁：指目标PE处于活动状态时(即进程)为其实施的补丁。PE文件被映像加载器装载到内存后，就变成进程，由Windows子系统调度PE映像里预先存放的指令代码完成指定的功能（常用于游戏修改器、动态调试、病毒生存等）
- 静态补丁：静态补丁框架由两部分组成：补丁程序和将补丁程序附加到PE的补丁工具


**插入程序:**

- 在PE空闲空间插入程序
- 在PE间隙中插入程序
- 在PE新增节中插入程序
- 在PE最后一节中插入程序

> PE空闲空间是指不需要对PE进行变形，且显示存在的可利用空间。位于`IMAGE_DOS_HEADER`结构内的54(36h)个字节，微软链接器生成的`DOS STUB`块程序的104(68h)个字节，位于`IMAGE_DATA_DIRECTORY`结构内的52(34h)个字节。


## 病毒保护技术

PE病毒因感染范围大，比直接在内存中感染和通过加载启动项加载的病毒还难清除，杀软通常只能删除，不能还原文件。

病毒为了能寄生到其他可执行程序中，使用了动态加载技术、静态补丁技术、重定位技术等，其为了逃脱AV检测和查杀，也会使用很多自我保护手段：

- 花指令：无用指令
- 在文件空隙中插入病毒片段、插入线程
- rootkit
- 加密算法
- 反跟踪技术
- 反调试技术
- 自修改技术(SMC)：对要运行的代码预先加密，在运行时将代码在内存实施再解密还原
- 注册表项保护技术（如添加自身启动）
- 进程保护技术:ring3下常见的进程保护大部分是通过注册系统服务或远程线程注入，或者通过HOOK一些API函数进行自我隐藏和保护。
- 引导型病毒:设定BIOS，中断13H的入口地址，使其指向病毒代码
- 无文件落地
- 脚本
- 加壳
 - 压缩壳
 - 加密壳(SMC)
 - 虚拟壳


rootkit：

- 用户态hook
- 内核态hook
- 直接内核操作对象


###病毒检测技术

- 检查磁盘的主引导扇区
- 检查各类文件
- 检查内存空间
- 特征值检测
- 校验和检测技术
- 启发式扫描技术
- 虚拟技术、沙箱技术


AV的病毒检测方式：

- 特征码扫扫描
- 静态启发式
- 动态启发式(虚拟机检测)
- 主动防御

手动分析病毒：

1. 静态分析
 - 采用反病毒引擎扫描(viruscan、火眼、VirusTotal)
 - 计算hash值,获取目标程序的指纹（比如用windows自带的md5deep，不仅限于找md5)
 - 查找字符串，找关键字(使用strings等工具，找到很少字符串，就可能被加壳了)
 - 侦壳操作(使用PEiD等工具)
 - 侦测动态链接(使用DependencyWalker等工具)
 - PE进程分析(PEview、PE Explorer等工具)
 - IDA Pro分析(反汇编、查找函数、栈分析、本地变量标识、重命名、流程图等)

2. 动态分析
 - 使用沙箱
 - 行为监控(Process Moniter、Regshot、Process Explore)
 - 调试器分析(OD、WinDbg等)























































